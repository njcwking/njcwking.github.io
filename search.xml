<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Xcode11新变化：SceneDelegate</title>
      <link href="2021/06/08/xcode11-xin-bian-hua-scenedelegate/"/>
      <url>2021/06/08/xcode11-xin-bian-hua-scenedelegate/</url>
      
        <content type="html"><![CDATA[<p>前几天更新好Xcode11后，运行旧项目，相安无事，心里捏了一把汗，终于没有跟往年那样一更新就给你一大堆报错了。刚才突发奇想，使用Xcode11新建iOS项目时,如果你跟往常一样在<code>Appdelegate</code>的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法中创建根控制器，会崩溃报错：</p><p><img src="http://njcwking.oss-cn-hangzhou.aliyuncs.com/uPic/1623105942381-5a56030c-ef5f-49a3-a2cc-2ffd1bd33f31.png" alt="崩溃"></p><p><code>Appdelegate</code>找不到设置window的方法。</p><p>然后发现Xcode自动新增了一个<code>SceneDelegate</code>文件，查找了一下官方文档<a href="https://links.jianshu.com/go?to=https://developer.apple.com/videos/play/wwdc2019/423/">WWDC2019：Optimizing App Launch</a></p><p>发现，iOS13中appdelegate的职责发现了改变：</p><p>iOS13之前，Appdelegate的职责全权处理App生命周期和UI生命周期；</p><p>iOS13之后，Appdelegate的职责是：</p><p>1、处理 App 生命周期</p><p>2、新的 Scene Session 生命周期</p><p>那UI的生命周期呢？交给新增的Scene Delegate处理</p><p>用图表示就是：</p><p>iOS13之前：</p><p><img src="http://njcwking.oss-cn-hangzhou.aliyuncs.com/uPic/1623105986947-f09ff842-1078-4bd4-a8fa-4d6159dfa667.png" alt="iOS13之前AppDelegate职责"></p><p>这种模式完全没问题，因为只有一个进程，只有一个与这个进程对应的用户界面</p><p>但是iOS13之后，<code>Appdelegate</code>不在负责UI生命周期，所有UI生命周期交给<code>SceneDelegate</code>处理：</p><p><img src="http://njcwking.oss-cn-hangzhou.aliyuncs.com/uPic/1623106063996-03f0dded-c0f6-44dd-8cdd-c6c3f9925d26.png" alt="iOS13之后AppDelegate职责"></p><p><img src="http://njcwking.oss-cn-hangzhou.aliyuncs.com/uPic/1623106081257-e800048a-96ac-4ab6-b088-f7d97ea68ef7.png" alt="iOS13之生SceneDelegate职责"></p><p>因此初始化window方法需要改变：</p><p>现在不再<code>Appdelegate</code>的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>进行初始化，转交给<code>SceneDelegate</code>的<code>willConnectToSession:</code>方法进行根控制器设置：</p><pre class="line-numbers language-none"><code class="language-none">- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {    UIWindowScene *windowScene = (UIWindowScene *)scene;    self.window = [[UIWindow alloc] initWithWindowScene:windowScene];    self.window.frame = windowScene.coordinateSpace.bounds;    self.window.rootViewController = [UITabBarController new];    [self.window makeKeyAndVisible];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若是想使用iOS13之前的方式，通过 <code>AppDelegate</code>来管理生命周期，可通过以下几个步骤进行还原：</p><p>1、 删除 <code>SceneDelegate</code> 的”.h”和”.m”文件；</p><p>2、 删除 <code>Info.plist</code> 文件中的 <code>Application Scene Manifest</code> 配置；</p><p>3、 删除 <code>AppDelegate.m</code> 文件中的两个管理SceneDelegate生命周期的代理方法；</p><pre class="line-numbers language-none"><code class="language-none">#pragma mark - UISceneSession lifecycle- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options {    // Called when a new scene session is being created.    // Use this method to select a configuration to create the new scene with.    return [[UISceneConfiguration alloc] initWithName:@"Default Configuration" sessionRole:connectingSceneSession.role];}- (void)application:(UIApplication *)application didDiscardSceneSessions:(NSSet&lt;UISceneSession *&gt; *)sceneSessions {    // Called when the user discards a scene session.    // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、  在 <code>AppDelegate.h</code> 中，添加window属性。</p><pre class="line-numbers language-none"><code class="language-none">@property(strong, nonatomic) UIWindow *window;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
            <tag> SceneDelegate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发：自定义View基础绘图方法（C语言Core Graphics实现篇）</title>
      <link href="2021/06/07/ios-kai-fa-zi-ding-yi-view-ji-chu-hui-tu-fang-fa-c-yu-yan-core-graphics-shi-xian-pian/"/>
      <url>2021/06/07/ios-kai-fa-zi-ding-yi-view-ji-chu-hui-tu-fang-fa-c-yu-yan-core-graphics-shi-xian-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-通用方法"><a href="#0x00-通用方法" class="headerlink" title="0x00 通用方法"></a>0x00 通用方法</h2><h3 id="1、获取当前上下文"><a href="#1、获取当前上下文" class="headerlink" title="1、获取当前上下文"></a>1、获取当前上下文</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取当前上下文CGContextRef ref = UIGraphicsGetCurrentContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、重绘"><a href="#2、重绘" class="headerlink" title="2、重绘"></a>2、重绘</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[self setNeedsDisplay];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、状态保存"><a href="#3、状态保存" class="headerlink" title="3、状态保存"></a>3、状态保存</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 状态保存CGContextSaveGState(ref);// 状态恢复CGContextRestoreGState(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、矩阵操作"><a href="#4、矩阵操作" class="headerlink" title="4、矩阵操作"></a>4、矩阵操作</h3><blockquote><p>矩阵方法必须在绘制之前调用</p></blockquote><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 平移CGContextTranslateCTM(ref,x,y);//缩放CGContextScaleCTM(ref,x,y);// 旋转CGContextRotateCTM(ref,angle);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、裁剪"><a href="#5、裁剪" class="headerlink" title="5、裁剪"></a>5、裁剪</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 裁剪CGContextClip(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、混合模式"><a href="#6、混合模式" class="headerlink" title="6、混合模式"></a>6、混合模式</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();/** *  kCGBlendModeClear,                  /* R = 0 */ *  kCGBlendModeCopy,                   /* R = S */ *  kCGBlendModeSourceIn,               /* R = S*Da */ *  kCGBlendModeSourceOut,              /* R = S*(1 - Da) */ *  kCGBlendModeSourceAtop,             /* R = S*Da + D*(1 - Sa) */ *  kCGBlendModeDestinationOver,        /* R = S*(1 - Da) + D */ *  kCGBlendModeDestinationIn,          /* R = D*Sa */ *  kCGBlendModeDestinationOut,         /* R = D*(1 - Sa) */ *  kCGBlendModeDestinationAtop,        /* R = S*(1 - Da) + D*Sa */ *  kCGBlendModeXOR,                    /* R = S*(1 - Da) + D*(1 - Sa) */ *  kCGBlendModePlusDarker,             /* R = MAX(0, (1 - D) + (1 - S)) */ *  kCGBlendModePlusLighter             /* R = MIN(1, S + D) */ **/CGContextSetBlendMode(con, kCGBlendModeClear);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、清除矩形区域"><a href="#7、清除矩形区域" class="headerlink" title="7、清除矩形区域"></a>7、清除矩形区域</h3><blockquote><p>依赖于上下文是否透明，透明则显示透明色，不透明显示黑色</p></blockquote><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 清除指定区域CGContextClearRect(ref, CGRectMake(0, 0, 100, 100));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01-绘制路径"><a href="#0x01-绘制路径" class="headerlink" title="0x01 绘制路径"></a>0x01 绘制路径</h2><h3 id="0、画图相关样式参数设置"><a href="#0、画图相关样式参数设置" class="headerlink" title="0、画图相关样式参数设置"></a>0、画图相关样式参数设置</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();...// 设置笔触颜色CGContextSetStrokeColorWithColor(ref, [UIColor blackColor].CGColor);// 设置笔触宽度CGContextSetLineWith(ref, 2);// 设置填充色// CGContextSetRGBFillColor(ref, 1, 0, 0, 1.0);CGContextSetFillColorWithColor(ref, [UIColor purpleColor].CGColor);//设置拐点样式//    enum CGLineJoin {//        kCGLineJoinMiter, //尖的，斜接//        kCGLineJoinRound, //圆//        kCGLineJoinBevel //斜面//    };CGContextSetLineJoin(ref, kCGLineJoinRound);//Line cap 线的两端的样式//    enum CGLineCap {//        kCGLineCapButt,//        kCGLineCapRound,//        kCGLineCapSquare//    };CGContextSetLineCap(ref, kCGLineCapSquare);//void CGContextSetLineDash (//                               CGContextRef c,//                               CGFloat phase, // 虚线从哪开始绘制//                               CGFloat* lengths, //虚线的长度CGFloat lengths[] = { 20, 5 };表示长度为20，间隙长度为5//                               CGFloat count, //lengths数组的个数//                               );// 设置虚线样式CGFloat lengths[] = { 20, 5 };CGContextSetLineDash(ref, 0, lengths, 2);...// 描出路径// CGContextDrawPath(ref, kCGPathStroke);CGContextStrokePath(ref);// 填充路径// CGContextDrawPath(ref, kCGPathFill);CGContextFillPath(ref);// 描出路径并设置填充CGContextDrawPath(ref, kCGPathFillStroke);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、-直线"><a href="#1、-直线" class="headerlink" title="1、 直线"></a>1、 直线</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();//使用C方式绘制路径CGMutablePathRef pathc = CGPathCreateMutable();CgPathMoveToPath(pathc, NULL, 50, 50);CgPathAddLineToPoint(pathc, NULL, 100, 100);/** * 在原有C的绘制路径方式再结合使用OC方式绘制路径 * 通过OC中bezierPathWithCGPath方式将C的路径转换成OC形式 */UIBezierPath *pathoc = [UIBezierPath bezierPathWithCGPath:pathc];// 设置路径起点[pathoc moveToPoint:CGPointMake(50,50)];// 添加线条[pathoc addLineToPoint:CGPointMake(100,150)];[pathoc addLineToPoint:CGPointMake(0,200)];//将OC的绘图方式转换成C并且添加到上下文中CGContextAddPath(ref,pathoc.CGPath);// 渲染视图CGContextStrokePath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、曲线"><a href="#2、曲线" class="headerlink" title="2、曲线"></a>2、曲线</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();//三次曲线函数//void CGContextAddCurveToPoint (//                               CGContextRef c,//                               CGFloat cp1x, //控制点1 x坐标//                               CGFloat cp1y, //控制点1 y坐标//                               CGFloat cp2x, //控制点2 x坐标//                               CGFloat cp2y, //控制点2 y坐标//                               CGFloat x,  //直线的终点 x坐标//                               CGFloat y  //直线的终点 y坐标//                               );CGContextMoveToPoint(ref, 200, 200);CGContextAddCurveToPoint(ref, 200, 0, 300, 200, 400, 100);CGContextStrokePath(ref);//三次曲线可以画圆弧，比如这里画一条之前用CGContextAddArcToPoint构成的圆弧CGContextMoveToPoint(ref, 200, 200);CGContextAddCurveToPoint(ref, 200, 100, 300, 100, 300 ,100);CGContextStrokePath(ref);//二次曲线函数//void CGContextAddQuadCurveToPoint (//                                   CGContextRef c,//                                   CGFloat cpx,  //控制点 x坐标//                                   CGFloat cpy,  //控制点 y坐标//                                   CGFloat x,  //直线的终点 x坐标//                                   CGFloat y  //直线的终点 y坐标//                                   );CGContextMoveToPoint(ref, 100, 100);CGContextAddQuadCurveToPoint(ref, 200, 0, 300, 150);CGContextStrokePath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、矩形"><a href="#3、矩形" class="headerlink" title="3、矩形"></a>3、矩形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 画矩形，长宽相等就是正方形CGContextAddRect(ref, CGRectMake(70,250,50,50));// 填充CGContextFillPath(ref);// 画矩形// CGContextStrokeRect(ref, CGRectMake(100, 120, 10, 10));// 填充矩形// CGContextFillRect(ref, CGRectMake(100, 120, 10, 10));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、圆角矩形"><a href="#4、圆角矩形" class="headerlink" title="4、圆角矩形"></a>4、圆角矩形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();CGFloat fw = 180;CGFloat fh = 280;CGFloat raduis = 10;// 通过路径画圆角矩形CGContextMoveToPoint(ref, fw, fh-20);  // 开始坐标右边开始CGContextAddArcToPoint(ref, fw, fh, fw-20, fh, raduis);  // 右下角角度CGContextAddArcToPoint(ref, 120, fh, 120, fh-20, raduis); // 左下角角度CGContextAddArcToPoint(ref, 120, 250, fw-20, 250, raduis); // 左上角CGContextAddArcToPoint(ref, fw, 250, fw, fh-20, raduis); // 右上角CGContextClosePath(ref);// 填充CGContextFillPath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、多边形"><a href="#5、多边形" class="headerlink" title="5、多边形"></a>5、多边形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();//画多边形，多边形是通过path完成的CGMutablePathRef path = CGPathCreateMutable();CGPathMoveToPoint(path, &amp;CGAffineTransformIdentity, 120, 250);CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 200, 250);CGPathAddLineToPoint(path, &amp;CGAffineTransformIdentity, 180, 300);CGPathCloseSubpath(path);CGContextAddPath(ref, path);// 填充CGContextFillPath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、椭圆（圆）"><a href="#6、椭圆（圆）" class="headerlink" title="6、椭圆（圆）"></a>6、椭圆（圆）</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 画椭圆，如果长宽相等就是圆CGContextAddEllipseInRect(ref, CGRectMake(0,250,50,50));// 填充CGContextFillPath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、圆形"><a href="#7、圆形" class="headerlink" title="7、圆形"></a>7、圆形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 画圆CGContextAddArc (ref, 100, 100, 50, 0, M_PI* 2 , 0);// 半圆CGContextAddArc (ref, 100, 200, 50, 0, M_PI, 0);// 描线CGContextStrokePath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、弧形"><a href="#8、弧形" class="headerlink" title="8、弧形"></a>8、弧形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();// 半圆弧// void CGContextAddArc(CGContextRef cg_nullable c, CGFloat x, CGFloat y,//     CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)// (x,y)：圆心位置// radius：圆半径// startAngle,endAngle：开始和结束角度// clockwise：0:顺时针 其它：逆时针CGContextAddArc (ref, 100, 200, 50, 0, M_PI, 0);// 描线CGContextStrokePath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9、扇形"><a href="#9、扇形" class="headerlink" title="9、扇形"></a>9、扇形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 获取图形上下文CGContextRef ref = UIGraphicsGetCurrentContext();CGContextMoveToPoint(ref, 160, 180); // void CGContextAddArc(CGContextRef cg_nullable c, CGFloat x, CGFloat y,//     CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)// (x,y)：圆心位置// radius：圆半径// startAngle,endAngle：开始和结束角度// clockwise：0:顺时针 其它：逆时针CGContextAddArc(ref, 160, 180, 30,  -60 * M_PI / 180, -120 * M_PI / 180, 1);CGContextClosePath(ref);// 描线CGContextStrokePath(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-文字"><a href="#0x02-文字" class="headerlink" title="0x02 文字"></a>0x02 文字</h2><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 定义文字字体样式UIFont *font = [UIFont boldSystemFontOfSize: 15.0];NSString *text = @"文字";// 将文字绘制到指定区域[text drawInRect: CGRectMake(10, 20, 80, 20) withFont: font];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-图片"><a href="#0x03-图片" class="headerlink" title="0x03 图片"></a>0x03 图片</h2><h3 id="1、自定义View-drawRect方法中调用"><a href="#1、自定义View-drawRect方法中调用" class="headerlink" title="1、自定义View.drawRect方法中调用"></a>1、自定义View.drawRect方法中调用</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIImage *image = [UIImage imageNamed:@"apple.jpg"];// 在指定的范围内绘制出完整图片[image drawInRect: CGRectMake(60, 340, 20, 20)];// 保持图片大小在point点开始画图片//[image drawAtPoint: CGPointMake(100, 340)];// 获取图形上下文// CGContextRef ref = UIGraphicsGetCurrentContext();// 使用这个绘制图片，图片会上下颠倒（原因：UIKit和CG坐标系y轴相反）// 解决办法：https://blog.csdn.net/ipoolo/article/details/84622028// CGContextDrawImage(ref, CGRectMake(60, 340, 20, 20), image.CGImage);// 绘制平铺图片// CGContextDrawTiledImage(ref, CGRectMake(0, 0, 24, 24), image.CGImage);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、创建和绘制图片"><a href="#2、创建和绘制图片" class="headerlink" title="2、创建和绘制图片"></a>2、创建和绘制图片</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 声明开始图片上下文UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0);// 获取图片上下文CGContextRef con = UIGraphicsGetCurrentContext();// 绘制CGContextAddEllipseInRect(con, CGRectMake(0,0,100,100));CGContextSetFillColorWithColor(con, [UIColor blueColor].CGColor);CGContextFillPath(con);// 生成图片UIImage* im = UIGraphicsGetImageFromCurrentImageContext();// 结束图片上下文UIGraphicsEndImageContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> iOS </tag>
            
            <tag> 绘制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发：自定义View基础绘图方法（OC语言UIKit实现篇）</title>
      <link href="2021/06/07/ios-kai-fa-zi-ding-yi-view-ji-chu-hui-tu-fang-fa-oc-yu-yan-uikit-shi-xian-pian/"/>
      <url>2021/06/07/ios-kai-fa-zi-ding-yi-view-ji-chu-hui-tu-fang-fa-oc-yu-yan-uikit-shi-xian-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-通用方法"><a href="#0x00-通用方法" class="headerlink" title="0x00 通用方法"></a>0x00 通用方法</h2><h3 id="1、设置颜色"><a href="#1、设置颜色" class="headerlink" title="1、设置颜色"></a>1、设置颜色</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 设置填充颜色[[UIColor greenColor] setFill];// 设置描线颜色[[UIColor redColor] setStroke];// 同时设置描线和填充的颜色[[UIColor blueColor] set];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、封装路径"><a href="#2、封装路径" class="headerlink" title="2、封装路径"></a>2、封装路径</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path;[path closePath]; // [path fill]时会自动把路径给关闭掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、重绘"><a href="#3、重绘" class="headerlink" title="3、重绘"></a>3、重绘</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[self setNeedsDisplay];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>该方法调用用，并不是立马调用View的重绘方法,只是设置一个标志.当下一次屏幕刷新的时候重绘。</p></blockquote><h3 id="4、状态保存"><a href="#4、状态保存" class="headerlink" title="4、状态保存"></a>4、状态保存</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">CGContextSaveGState(ref);CGContextRestoreGState(ref);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5、矩阵操作"><a href="#5、矩阵操作" class="headerlink" title="5、矩阵操作"></a>5、矩阵操作</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">CGContextTranslateCTM(ref,x,y); // 必须在添加路径之前CGContextScaleCTM(ref,x,y);CGContextRotateCTM(ref,angle);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6、移除路径"><a href="#6、移除路径" class="headerlink" title="6、移除路径"></a>6、移除路径</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPath];[path removeAllPoints];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、添加路径"><a href="#7、添加路径" class="headerlink" title="7、添加路径"></a>7、添加路径</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPath];UIBezierPath *path2 = [UIBezierPath bezierPath];[path2 appendPath: path];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="8、裁剪"><a href="#8、裁剪" class="headerlink" title="8、裁剪"></a>8、裁剪</h3><blockquote><p>设置裁剪后在这以后的图形绘制超出当前路径范围则不可见，可使用CGContextSaveGState/CGContextRestoreGState配合保存恢复状态</p></blockquote><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 设置裁剪区域UIBezierPath *clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 200, 200)];// 添加裁剪[clipPath addClip];// 矩形裁剪// UIRectClip(CGRectMake(0, 0, 200, 200));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9、绘制上下文转换"><a href="#9、绘制上下文转换" class="headerlink" title="9、绘制上下文转换"></a>9、绘制上下文转换</h3><blockquote><p>UIKit的绘制必须在当前的上下文中绘制，而UIGraphicsPushContext可以将当前的参数context转化为可以UIKit绘制的上下文，进行绘制图片。</p></blockquote><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 绘制图层内容的代理方法中进行绘图任务-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{  UIImage *image = [UIImage imageNamed:@"test.jpg"];  UIGraphicsPushContext(ctx);  [image drawInRect:CGRectMake(0, 0, 300, 300)];  UIGraphicsPopContext();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01-绘制路径"><a href="#0x01-绘制路径" class="headerlink" title="0x01 绘制路径"></a>0x01 绘制路径</h2><h3 id="0、画图相关样式参数设置"><a href="#0、画图相关样式参数设置" class="headerlink" title="0、画图相关样式参数设置"></a>0、画图相关样式参数设置</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPath];// 设置路径线条宽度path.lineWidth = 20;//设置拐点样式//    enum CGLineJoin {//        kCGLineJoinMiter, //尖的，斜接//        kCGLineJoinRound, //圆//        kCGLineJoinBevel //斜面//    };path.lineJoinStyle = kCGLineJoinBevel;//Line cap 线的两端的样式//    enum CGLineCap {//        kCGLineCapButt,//        kCGLineCapRound,//        kCGLineCapSquare//    };path.lineCapStyle = kCGLineCapSquare;// 设置填充颜色[[UIColor greenColor] setFill];// 设置笔触颜色[[UIColor redColor] setStroke];// 关闭路径// [path closePath];// [path fill]时会自动把路径给关闭掉// 描出路径[path stoke];// 填充路径[path fill];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、-直线"><a href="#1、-直线" class="headerlink" title="1、 直线"></a>1、 直线</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPath];// 设置路径起点[path moveToPoint:CGPointMake(50,50)];// 添加线条[path addLineToPoint:CGPointMake(100,150)];[path addLineToPoint:CGPointMake(0,200)];// 描线[path stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、曲线"><a href="#2、曲线" class="headerlink" title="2、曲线"></a>2、曲线</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPath];// 设置起始点[path moveToPoint:CGPointMake(10, 280)];// 画曲线(controlPoint:弯曲方向点)[path addQuadCurveToPoint:CGPointMake(180, 280) controlPoint:CGPointMake(130, 130)];// 三次曲线函数(controlPoint1和controlPoint2为两个控制点)// [path addCurveToPoint:CGPointMake(180, 280) controlPoint1:CGPointMake(130, 130) controlPoint2:CGPointMake(140, 140)];// 描线[path stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、矩形"><a href="#3、矩形" class="headerlink" title="3、矩形"></a>3、矩形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 200, 100)];[path1 stroke];//快速方法填充矩形//UIRectFill(CGRectMake(50, 50, 200, 100));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、圆角矩形"><a href="#4、圆角矩形" class="headerlink" title="4、圆角矩形"></a>4、圆角矩形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 圆角矩形，半径等于宽高一半时为圆形UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(50,50,100,100) cornerRadius: 20];[path stroke];// 部分圆角矩形UIBezierPath *partCornerPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(100, 100, 100, 100) byRoundingCorners:(UIRectCornerTopLeft |UIRectCornerTopRight) cornerRadii:CGSizeMake(10, 10)];[partCornerPath stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、圆形"><a href="#5、圆形" class="headerlink" title="5、圆形"></a>5、圆形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 一、使用圆角矩形方式画圆// UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(50,50,100,100) cornerRadius: 50];// [path stroke];// 二、使用椭圆方式画圆UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 180, 200, 200)];[path stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、椭圆"><a href="#6、椭圆" class="headerlink" title="6、椭圆"></a>6、椭圆</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 180, 200, 100)];[path stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、弧形"><a href="#7、弧形" class="headerlink" title="7、弧形"></a>7、弧形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 使用弧形初始化路径UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 160) radius:100 startAngle:M_PI_2*3 endAngle:0 clockwise:YES];[path stroke];// 添加弧形路径// [path addArcWithCenter:CGPointMake(160, 160) radius:100 startAngle:M_PI_2*3 endAngle:0 clockwise:YES];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、扇形"><a href="#8、扇形" class="headerlink" title="8、扇形"></a>8、扇形</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">CGPoint center = CGPointMake(100, 430);CGFloat radius = 100;// 画弧度 clockwise:方向(顺时针或是逆时针)UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0 endAngle:M_PI_4*3 clockwise:YES];// 画扇形[path addLineToPoint:center];//[path closePath];// 从路径终点连接一根线到路径的起点[path fill];// fill填充之前,会自动关闭路径//[path stroke];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-文字"><a href="#0x02-文字" class="headerlink" title="0x02 文字"></a>0x02 文字</h2><h3 id="1、设置字体属性"><a href="#1、设置字体属性" class="headerlink" title="1、设置字体属性"></a>1、设置字体属性</h3><blockquote><p>可查看<code>NSAttributedString</code>头文件中的属性</p></blockquote><table><thead><tr><th>Key值</th><th>取值类型</th><th>含义</th></tr></thead><tbody><tr><td>NSFontAttributeName</td><td>UIFont</td><td>字体名称</td></tr><tr><td>NSForegroundColorAttributeName</td><td>UIColor</td><td>文字前景色</td></tr><tr><td>NSBackgroundColorAttributeName</td><td>UIColor</td><td>文字背景色</td></tr><tr><td>NSUnderlineStyleAttributeName</td><td>NSNumber</td><td>下划线样式，参考NSUnderlineStyle<br>NSUnderlineStyleNone : 0<br>NSUnderlineStyleSingle: 1<br>NSUnderlineStyleDouble: 9</td></tr><tr><td>NSStrokeColorAttributeName</td><td>UIColor</td><td>描边颜色</td></tr><tr><td>NSStrokeWidthAttributeName</td><td>NSNumber</td><td>描边宽度</td></tr><tr><td>NSShadowAttributeName</td><td>NSShadow</td><td>阴影</td></tr><tr><td>NSUnderlineColorAttributeName</td><td>UIColor</td><td>下划线颜色，默认与前景色一致</td></tr></tbody></table><h3 id="2、计算文字宽高"><a href="#2、计算文字宽高" class="headerlink" title="2、计算文字宽高"></a>2、计算文字宽高</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSString *str = @"这是一段文字";// 计算文字的高度CGRect textFrame = [str boundingRectWithSize: CGSizeMake(200, 999) options:NSStringDrawingUsesLineFragmentOrigin attributes:attributes context:nil];// 绘制文字[str drawInRect: CGRectMake(50, 50, textFrame.size.width, textFrame.size.height) withAttributes:attributes];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、绘制文字"><a href="#3、绘制文字" class="headerlink" title="3、绘制文字"></a>3、绘制文字</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSString *str = @"这是一段文字";NSDictionary *attributes = @{NSFontAttributeName: [UIFont systemFontOfSize:20],NSForegroundColorAttributeName: [UIColor redColor]};// 绘制文字，文字不会自动换行[str drawAtPoint: CGPointMake(30, 30) withAttributes:attributes];// 绘制文字，文字会在指定的区域内自动换行// [str drawInRect: CGRectMake(30, 30, 150, 200) withAttributes:attributes];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-图片"><a href="#0x03-图片" class="headerlink" title="0x03 图片"></a>0x03 图片</h2><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIImage *image = [UIImage imageNamed: @"text.jpg"];// 绘制出来的图片是保持原来图片大小[image drawAtPoint:CGPointZero];//把图片填充到指定Rect中[image drawInRect:rect];//图片平铺绘制[image drawAsPatternInRect: rect];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、图片处理</p><p>五、定时绘制</p><pre class="line-numbers language-none"><code class="language-none">[NSTimer scheduledTimerWithTimeInterval]// 每次屏幕刷新时调用CADisplayLink *link;[link addToRunLoop];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、自定义View-drawRect方法中调用"><a href="#1、自定义View-drawRect方法中调用" class="headerlink" title="1、自定义View.drawRect方法中调用"></a>1、自定义View.drawRect方法中调用</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">UIImage *image = [UIImage imageNamed: @"text.jpg"];// 绘制出来的图片是保持原来图片大小[image drawAtPoint:CGPointZero];//把图片填充到指定Rect中[image drawInRect:rect];//图片平铺绘制[image drawAsPatternInRect: rect];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、创建和绘制图片"><a href="#2、创建和绘制图片" class="headerlink" title="2、创建和绘制图片"></a>2、创建和绘制图片</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 声明开始图片上下文UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0);// 绘制UIBezierPath* p = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0,0,100,100)];[[UIColor blueColor] setFill];[p fill];// 生成图片UIImage* im = UIGraphicsGetImageFromCurrentImageContext();// 结束图片上下文UIGraphicsEndImageContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x04-定时绘制"><a href="#0x04-定时绘制" class="headerlink" title="0x04 定时绘制"></a>0x04 定时绘制</h2><h3 id="1、NSTimer定时器"><a href="#1、NSTimer定时器" class="headerlink" title="1、NSTimer定时器"></a>1、NSTimer定时器</h3><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">[NSTimer scheduledTimerWithTimeInterval:0.025 target:self selector:@selector(update) userInfo:nil repeats:YES];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><font color="red">注意：</font></p><p>如果我们使用NSTimer定时器. 设置的执⾏行时间为0.025秒, 假如屏幕刷新时间为0.035.中间就会等待0.010<br>绘制图形的时候不建议使用该方法</p></blockquote><h3 id="2、CADisplayLink定时器"><a href="#2、CADisplayLink定时器" class="headerlink" title="2、CADisplayLink定时器"></a>2、CADisplayLink定时器</h3><h4 id="2-1-什么时CADisplayLink"><a href="#2-1-什么时CADisplayLink" class="headerlink" title="2.1 什么时CADisplayLink"></a>2.1 什么时CADisplayLink</h4><p><strong>CADisplayLink</strong>是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 <strong>CADisplayLink</strong>对象，把它添加到一个<strong>runloop</strong>中，并给它提供一个 <strong>target</strong>和<strong>selector</strong>在屏幕刷新的时候 调用 。</p><p>一但 <strong>CADisplayLink</strong> 以特定的模式注册到<strong>runloop</strong>之后，每当屏幕需要刷新的时候，<strong>runloop</strong>就会调用<strong>CADisplayLink</strong>绑定的<strong>target上</strong>的<strong>selector</strong>，这时<strong>target</strong>可以读到 <strong>CADisplayLink</strong> 的每次调用的时间戳，用来准备下一帧显示需要的数据。</p><h4 id="2-2-使用方法"><a href="#2-2-使用方法" class="headerlink" title="2.2 使用方法"></a>2.2 使用方法</h4><blockquote><p>我们在绘制的时候使用定时器最好使用CADisplayLink. 创建CADisplayLink定时器 这个定时器⽅法它是当每次屏幕刷新的时候调⽤(屏幕每一秒刷新60次);<br>使⽤用CADisplayLink不需要考虑时间间隔。</p></blockquote><pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">// 定义定时器CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(update)]; //要让它工作, 必须得要把定时器添加到主运行循环 [link addToRunLoop:[NSRunLoop mainRunLoop]forMode:NSDefaultRunLoopMode];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> iOS </tag>
            
            <tag> 绘制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
